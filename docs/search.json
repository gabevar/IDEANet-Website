[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducing IDEANet - Integrating Data Exchange and Analysis for Networks",
    "section": "",
    "text": "Over the last 40 years, network analysis has emerged as a prominent approach to data-intensive research. Despite this steady growth and investment, network analysis remains something of a niche specialty that can exclude novice users who usually only receive standard statistical training. Moreover, since much of the growth in network science has tended to be field-specific, tools and formats have developed independently across disciplines. The multiplicity of formats and sensitivity of social data makes existing records difficult to share across scholars in the field, limiting the opportunity for new findings on the already accumulated body of network data. IDEANet - Integrating Data Exchange and Analysis for Networks - aims to maximize scientific discovery in human network science by significantly lowering the analytic and access barriers-to-entry for researchers. IDEANet is supported by the National Science Foundation as part of the Human Networks and Data Science - Infrastructure program (BCS-2024271 and BCS-2140024).\nIDEAnet features three key components (1) a suite of analysis tools developed in R which automatically generate standardized network analytic measures (2) a GUI (Graphical User Interface) which gives access to the aforementioned measurements through an easy-to-use menu-based program and (3) a secure data repository that routinizes the capacity for archiving and accessing network data, including sensitive data.\nThe analysis tools are distributed as a package and built with real-world data constraints in mind to allow novice users the ability to gain substantive results as efficiently (but still accurately) as possible. Core metrics comprise 17 node-level measurement (e.g., degree, centralities, reachability) in addition to 27 system-level metrics (e.g., network size, dyad census, transitivity). Additional modules include multiple regression QAP, multi-relational blockmodeling and a community-detection routine that partitions the network based on 10 commonly used methods and evaluates their concordance using CHAMP. Further modules are in development including meta-population disease simulation and dynamic network diffusion simulation.\nThe secure data repository is hosted on Dataverse in collaboration with Duke University Library. Researchers are often interested in sharing their data but can be limited by strict institutional requirements. Our repository facilitates this transition by offering three levels of data security: Open access, Secure non-restricted, and Secure use-restricted. Secure non-restricted data include some level of confidentiality such that investigators require IRB approval for access. Secure use-restricted data requires both IRB approval for use and further substantive limitations required by the data owner. To accommodate the diversity in requirements, IDEAnet makes use of the imPACT architecture – a “notary service” that seamlessly matches user certification and data access requirements.\nThe difficult learning curve involved in learning network tools means that researchers with substantive interests in network processes but who are not specially trained in network methods must either invest heavily in training or risk serious analytic errors. The goal of IDEANet is to provide an integrated network data analysis framework within R that capitalizes on the best of current tools while building robust safeguards against common data and analytic errors.\nThis website serves as the home for IDEANet and contains vignettes describing how to use the package in R, navigate the GUI and access the data repository. If you have any questions, feel free to use the contact information located in our Contact Us page.\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#introducing-ideanet---integrating-data-exchange-and-analysis-for",
    "href": "index.html#introducing-ideanet---integrating-data-exchange-and-analysis-for",
    "title": "Introducing IDEANet - Integrating Data Exchange and Analysis for Networks",
    "section": "",
    "text": "Networks\nOver the last 40 years, network analysis has emerged as a prominent approach to data-intensive research. Despite this steady growth and investment, network analysis remains something of a niche specialty that can exclude novice users who usually only receive standard statistical training. Moreover, since much of the growth in network science has tended to be field-specific, tools and formats have developed independently across disciplines. The multiplicity of formats and sensitivity of social data makes existing records difficult to share across scholars in the field, limiting the opportunity for new findings on the already accumulated body of network data. IDEANet - Integrating Data Exchange and Analysis for Networks - aims to maximize scientific discovery in human network science by significantly lowering the analytic and access barriers-to-entry for researchers. IDEANet is supported by the National Science Foundation as part of the Human Networks and Data Science - Infrastructure program (BCS-2024271 and BCS-2140024).\nIDEAnet features three key components (1) a suite of analysis tools developed in R which automatically generate standardized network analytic measures (2) a GUI (Graphical User Interface) which gives access to the aforementioned measurements through an easy-to-use menu-based program and (3) a secure data repository that routinizes the capacity for archiving and accessing network data, including sensitive data.\nThe analysis tools are distributed as a package and built with real-world data constraints in mind to allow novice users the ability to gain substantive results as efficiently (but still accurately) as possible. Core metrics comprise 17 node-level measurement (e.g., degree, centralities, reachability) in addition to 27 system-level metrics (e.g., network size, dyad census, transitivity). Additional modules include multiple regression QAP, multi-relational blockmodeling and a community-detection routine that partitions the network based on 10 commonly used methods and evaluates their concordance using CHAMP. Further modules are in development including meta-population disease simulation and dynamic network diffusion simulation.\nThe secure data repository is hosted on Dataverse in collaboration with Duke University Library. Researchers are often interested in sharing their data but can be limited by strict institutional requirements. Our repository facilitates this transition by offering three levels of data security: Open access, Secure non-restricted, and Secure use-restricted. Secure non-restricted data include some level of confidentiality such that investigators require IRB approval for access. Secure use-restricted data requires both IRB approval for use and further substantive limitations required by the data owner. To accommodate the diversity in requirements, IDEAnet makes use of the imPACT architecture – a \"notary service\" that seamlessly matches user certification and data access requirements.\nThe difficult learning curve involved in learning network tools means that researchers with substantive interests in network processes but who are not specially trained in network methods must either invest heavily in training or risk serious analytic errors. The goal of IDEANet is to provide an integrated network data analysis framework within R that capitalizes on the best of current tools while building robust safeguards against common data and analytic errors."
  },
  {
    "objectID": "contact_us.html",
    "href": "contact_us.html",
    "title": "Contact Us",
    "section": "",
    "text": "We are continually improving our tool and adding features. If you run into any issues, please add an issue directly on our Github page. If you would like to collaborate on development, propose a pull request directly on our Github page as well.\nYou can contact the IDEANet team directly at gv42@duke.edu.\n\n\n\n Back to top"
  },
  {
    "objectID": "vignette.html",
    "href": "vignette.html",
    "title": "R Vignette",
    "section": "",
    "text": "The goal of the IDEANet program is to lower the barrier of entry to network analysis for scholars interested in relational measurement. Some researchers may have data and questions that are suitable to network analysis. And yet, getting comfortable with the tools available in R can prove to be an arduous and time consuming task.\nIDEANet is a set of functions which leverages existing network analysis packages in R (igraph, network, sna) to provide high quality measurements seamlessly from the starting data. The team behind IDEANet in collaboration with the Duke University Library Services have also created a repository of publicly available network datasets which researchers can pull from or host their own data. If you are interested in hosting your own data, feel free to fill out the form available on our Database page.\nIDEANet is supported by the National Science Foundation as part of the Human Networks and Data Science - Infrastructure program (BCS-2024271 and BCS-2140024)."
  },
  {
    "objectID": "vignette.html#setting-up-ideanet",
    "href": "vignette.html#setting-up-ideanet",
    "title": "IDEANet R Vignette",
    "section": "Setting up IDEANet",
    "text": "Setting up IDEANet\nLets begin by importing IDEANet. IDEANet is currently available only as a Github package and requires a direct download using devtools.\n\nlibrary(devtools)\n\nLoading required package: usethis\n\ninstall_github(\"https://github.com/Tom-Wolff/ideanet\")\n\nSkipping install of 'ideanet' from a github remote, the SHA1 (a5f256cd) has not changed since last install.\n  Use `force = TRUE` to force installation\n\nlibrary(ideanet)\n\nIn this vignette, we will be using the datasets included with the package. IDEANet comes with a variety of datasets we can explore using the data() function\n\ndata(package = \"ideanet\")\n\nIn this vignette, we will use the Fauxmesa dataset. The data represents a simulation of friendships among students in a school.\n\ndata(fauxmesa)\n\nhead(fauxmesa_edges)\n\n  from to\n1    1 25\n2    1 52\n3    1 58\n4    1 70\n5    1 87\n6    1 92\n\nhead(fauxmesa_nodes)\n\n  id grade  race sex\n1  1     7  Hisp   F\n2  2     7  Hisp   F\n3  3    11 NatAm   M\n4  4     8  Hisp   M\n5  5    10 White   F\n6  6    10  Hisp   F"
  },
  {
    "objectID": "vignette.html#running-netwrite",
    "href": "vignette.html#running-netwrite",
    "title": "R Vignette",
    "section": "Running netwrite()",
    "text": "Running netwrite()\nThe central analysis component of IDEANet is accessed via the netwrite() function. netwrite() comes with a breadth of arguments described in the netwrite() documentation. The documentation can be accessed with the following code, or by via our webpage (link).\n\n?netwrite()\n\nReturning to our high-school example, we can ask IDEANet to return basic network measurements on the network by including some basic arguments: what kind of network object we are using – in this case, an edgelist – and some information about sources, targets and their directionality.\n\nrm(list=ls())\n\ndata(fauxmesa)\n\nnetwrite(data_type = \"edgelist\", \n         i_elements = fauxmesa_edges$from, \n         j_elements = fauxmesa_edges$to,\n         directed = T)\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Network consists of 2+ unconnected components. Eigenvector centrality scores will be calculated for nodes based on their position within their respective components.\n\n\nWarning in igraph::centralization.evcent(g_no_iso, directed = TRUE, normalized\n= TRUE): At core/centrality/centrality_other.c:329 : graph is directed and\nacyclic; eigenvector centralities will be zeros.\n\n\nWarning in k_cohesion(graph = g): Graph will be treated as undirected for\ncalculation of k-core cohesion measure.\n\n\nnetwrite() includes a series of warnings that warns you about the way certain measurements are calculated. In this case, while most metrics are calculated as directed (as we requested in the function), some functions such as power centrality and eigenvector centrality require interpreting the network as undirected.\nWhile this successfully returned the metric we will be exploring further in this vignette, netwrite() has additional quality of life arguments that we can use with our example. For example, we want to include node level attributes and change the name of our output network.\nHowever, notice that there are students in our nodelist that don’t exist in our edgelist.\n\nsetdiff(fauxmesa_nodes$id, fauxmesa_edges$from) %&gt;% head()\n\n[1]  3  4  6  7 10 12\n\n\nIn this case, netwrite() will consider additional student’s as isolates in the network.\n\nrm(list=ls()) # get a clean slate\n\ndata(fauxmesa) # bring in our data again\n\nnetwrite(data_type = \"edgelist\", \n         i_elements = fauxmesa_edges$from, \n         j_elements = fauxmesa_edges$to,\n         directed = T,\n         nodelist = fauxmesa_nodes,\n         node_id = \"id\",\n         net_name = \"fauxmesa_network\")\n\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Isolates detected in network. Isolates will be removed from network when calculating eigenvector centrality measure, and will be assigned NA values in final output.\n\n\n(Eigenvector centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Network consists of 2+ unconnected components. Eigenvector centrality scores will be calculated for nodes based on their position within their respective components.\n\n\nWarning in igraph::centralization.evcent(g_no_iso, directed = TRUE, normalized\n= TRUE): At core/centrality/centrality_other.c:329 : graph is directed and\nacyclic; eigenvector centralities will be zeros.\n\n\nWarning in k_cohesion(graph = g): Graph will be treated as undirected for\ncalculation of k-core cohesion measure."
  },
  {
    "objectID": "vignette.html#netwrite-interpretation",
    "href": "vignette.html#netwrite-interpretation",
    "title": "R Vignette",
    "section": "netwrite() interpretation",
    "text": "netwrite() interpretation\nnetwrite() offers a variety of outputs that facilitate a clear interpretation of the network structure. Starting from the top, the output contains system level measures that tell the researcher about the network’s overall characteristics.\n\nsystem_measure_plot\n\n\n\n\nThese measurements are also available in traditional table form.\n\nsystem_level_measures %&gt;% rmarkdown::paged_table()\n\n\n\n  \n\n\n\nnetwrite() also outputs a graph object that contains each node and edge-level measurement computed within the function. This graph object allows for traditional network manipulation, such as plotting.\n\nplot(fauxmesa_network, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0.2)\n\n\n\n\nNote that the output network can contain both isolates and self-loops. Isolates were included when we defined a list of node ids (including isolate) in the “nodelist” argument of netwrite(). There is currently no method for removing self-loops within netwrite() - instead, the user is expected to remove any unwanted edges before reading them into netwrite().\nIn addition to the full network, researchers may be interested in the shape of major sub-components. netwrite() outputs two additional graph objects: the largest component in the network.\n\nplot(largest_component, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0.2, \n     main = \"largest component\")\n\n\n\n\nAnd the largest bi-component of the network.\n\nplot(largest_bi_component, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0.2, \n     main = \"largest bi-component\")\n\n\n\n\nnetwrite() also outputs an edgelist dataframe of the same length as the input edges. This edgelist object contains unique dyad-level ids, internal ego and alter ids, the original id values and weights (uniformly set to 1 if no weights are defined).\n\nhead(edgelist) %&gt;% rmarkdown::paged_table()\n\n\n\n  \n\n\n\nLastly, netwrite() returns measurement at the node level as a dataframe of values and a plot of distributions. Certain measurements are computed only under certain weight and edge direction conditions - that is, the nodelist only contains measurements appropriate to the network features.\n\nhead(node_measures) %&gt;% rmarkdown::paged_table()\n\n\n\n  \n\n\nnode_measure_plot"
  },
  {
    "objectID": "vignette.html#multilayered-networks",
    "href": "vignette.html#multilayered-networks",
    "title": "R Vignette",
    "section": "Multilayered networks",
    "text": "Multilayered networks\nIDEANet can also handle multilayered networks. For example, we may be interested in both marriage and business between elite Florentine families that gave rise to the prominence of the house of Medici. This data is available in the IDEANet package and contains a layer column that indicates if the relationships are marriage ties or business ties.\n\nrm(list=ls()) # get a clean slate\n\ndata(florentine) # bring in our florentine families data\n\nflorentine &lt;- florentine %&gt;% \n  mutate(layer = case_when(layer == 1 ~ \"marriage\", T ~ \"business\"))\n\nhead(florentine, 10)\n\n   node target weight    layer\n1     0      8      1 marriage\n2     1      5      1 marriage\n3     1      6      1 marriage\n4     1      8      1 marriage\n5     2      4      1 marriage\n6     2      8      1 marriage\n7     2      4      1 business\n8     2      5      1 business\n9     2      8      1 business\n10    2     10      1 business\n\n\nTaking advantage of these layers in netwrite() is easy: just indicate which column contains your layer information using the type argument.\n\nnetwrite(data_type = \"edgelist\", \n         i_elements = florentine$node, \n         j_elements = florentine$target,\n         directed = F,\n         type = florentine$layer, # indicate layer variable\n         net_name = \"florentine_network\")\n\nProcessing network for edge type marriage\n\n\nProcessing network for edge type business\n\n\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n\n\n(Eigenvector centrality) Isolates detected in network. Isolates will be removed from network when calculating eigenvector centrality measure, and will be assigned NA values in final output.\n\n\nProcessing aggregate network of all edge types\n\n\nJoining with `by = join_by(id, attr)`\nJoining with `by = join_by(id, attr)`\n\n\nRunning netwrite() on multi-layered network will yield some additional warnings that netwrite() is being computed on each layer separately, and on a network containing aggregated layers.\nWhen given a multi-layered network to work with, netwrite() will return the outputs described previously in slightly different ways. First, we can see that the edgelist object contains every type of tie, and comes paired with a list object edgelists_list that separates each type of connection into their own edgelist.\n\nhead(edgelist) %&gt;% rmarkdown::paged_table()\n\n\n\n  \n\n\nsummary(edgelist_list)\n\n              Length Class      Mode\nsummary_graph 7      data.frame list\nmarriage      6      data.frame list\nbusiness      6      data.frame list\n\n\nThe same is true of the node_measures object and its associated list object node_measures_list. For node measurements, variables with no tie-type prefix are calculated using every type of tie, while measurements calculated on a specific sub-network have the associated tie-type prefix. For example, in this example we see 3 different values for total degree, one for marriage ties, one for business ties and a value without prefix that represents the metric for the aggregate network.\n\nnode_measures %&gt;% \n  dplyr::select(id, total_degree, marriage_total_degree, business_total_degree) %&gt;%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\nEvery other expected output are constructed as list objects and have the “_list” suffix. Lists can be accessed to access metric at different layers of the network, or the network with aggregated layers. For example, we can access the “network_list” object and extract the three layer-associated graphs.\n\nsummary(network_list) # Check in which position each sub-network is\n\n              Length Class  Mode\nsummary_graph 15     igraph list\nmarriage      15     igraph list\nbusiness      15     igraph list\n\npar(mfrow = c(2, 2), mar = c(1, 1, 1, 1))\nset.seed(123)\nplot(network_list$summary_graph, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2, \n     vertex.color = \"red\", main = \"Aggregate network\")\nplot(network_list$marriage, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2, \n     vertex.color = \"gray\", main = \"Marriage network\")\nplot(network_list$business, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0.2, \n     vertex.color = \"green\", main = \"Business network\")"
  },
  {
    "objectID": "vignette.html#mrqap",
    "href": "vignette.html#mrqap",
    "title": "R Vignette",
    "section": "MRQAP",
    "text": "MRQAP\nMRQAP is an extension of the Mantel test which uses node-permutation in order to get around issues of non-independence that make a traditional regression analysis difficult when using network data. This module can be useful if the researcher has a question about the probability of a tie existing or the likelihood that tie will have a specific dyadic feature.\nFor example, we may be interested in the following question about adolescent friendships in high-school: Is being of the same self-identified sex (e.g., sex homophily) increase the likelihood of a relationship? Are white students more likely to be friends with other white students (e.g., race homophily)?\nFirst, let’s reset our environment and return to the high-school data introduced earlier in the vignette:\n\nrm(list=ls()) # get a clean slate\n\ndata(fauxmesa) \n\nnetwrite(data_type = \"edgelist\", \n         i_elements = fauxmesa_edges$from, \n         j_elements = fauxmesa_edges$to,\n         directed = T,\n         nodelist = fauxmesa_nodes,\n         node_id = \"id\",\n         net_name = \"fauxmesa_network\")\n\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Bonacich power centrality) Isolates detected in network. Isolates will be removed from network when calculating power centrality measure, and will be assigned NA values in final output.\n\n\n(Bonacich power centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Isolates detected in network. Isolates will be removed from network when calculating eigenvector centrality measure, and will be assigned NA values in final output.\n\n\n(Eigenvector centrality) Adjacency matrix for network is singular. Network will be treated as undirected in order to calculate measures\n\n\n(Eigenvector centrality) Network consists of 2+ unconnected components. Eigenvector centrality scores will be calculated for nodes based on their position within their respective components.\n\n\nWarning in igraph::centralization.evcent(g_no_iso, directed = TRUE, normalized\n= TRUE): At core/centrality/centrality_other.c:329 : graph is directed and\nacyclic; eigenvector centralities will be zeros.\n\n\nWarning in k_cohesion(graph = g): Graph will be treated as undirected for\ncalculation of k-core cohesion measure.\n\n\nBy adding a nodelist to our netwrite() function, we automatically add race and gender variables to the outputted network object.\n\nigraph::V(fauxmesa_network)$race %&gt;% head()\n\n[1] \"Hisp\"  \"Hisp\"  \"NatAm\" \"Hisp\"  \"White\" \"Hisp\" \n\nigraph::V(fauxmesa_network)$sex %&gt;% head()\n\n[1] \"F\" \"F\" \"M\" \"M\" \"F\" \"F\"\n\n\nWe have information about student’s race and sex at the node level; however, MRQAP expects all information to be dyadic - in other words, we need to move from individual level information to comparisons between student’s in the relationships. For example, we may want to know if the sex of two students in a relationships is the same or not. For our second question, we only want to know if both students are white, not if they share the same race in general.\nTo make this reformatting step more accessible, IDEANet offer the qap_setup() function. This function can work independently of the netwrite() output, although we recommend its output as the input for all analysis modules.\n\nqap_setup(net = fauxmesa_network, \n          variables = c(\"race\", \"sex\"),\n          methods = c(\"multi_category\", \"reduced_category\"), \n          directed = T)\n\nqap_setup() provides three possible methods for transforming data:\n\n“multi_category”: Applies to categorical variables only. It creates as many variables as there are unique values; each variable signals if both ego and alter have the given value.\n“reduced_category”: Applies to categorical variables only. Creates a single variable that signals if alter and ego have the same value.\n“both”: Applies to categorical variables only. Computes both the “multi_category” and “reduced_category” methods.\n“difference”: Applies to numeric variables only. Computes the difference in input value between ego and alter.\n\nqap_setup() produces a list object qap_results that contains:\n\nAn igraph object that includes the newly computed edge variables\nA nodelist\nAn edgelist that includes the newly computed edge variables.\n\n\nsummary(qap_results)\n\n     Length Class      Mode\n[1,] 205    igraph     list\n[2,]  31    data.frame list\n[3,]  13    data.frame list\n\nqap_results[[3]] %&gt;% rmarkdown::paged_table()\n\n\n\n  \n\n\n\nqap_setup() function returns several new variables. Variables appended with “_ego” and “_alter” represent the original values pulled from the nodelist. Since we associated our race variable with the multi-categorymethod, qap_setup() also returned a variable that indicates if both ego and alter share that particular racial identification. Since we associated the sex variable with the reduced-category method, we receive a single variable that indicates if ego and alter share the same sex.\nWith our variables of interest in hand, we can turn to the MRQAP analysis itself. The IDEANet MRQAP module provides the qap_run() function which integrates seamlessly with the output from netwrite() and qap_setup(). Arguments for qap_run() toggles for the number of permutations and the family of the model (currently, linear and binomial). See function description for more information. If the dependent argument is left NULL, the function defaults to predicting the probability of tie.\nNOTE: Binomial MRQAP is very sensitive to model specification; for exploratory purposes, it is recommended to stick to a linear functional form. We significantly decrease the number of permutations to allow for lower computation times, though this may make our confidence intervals less interpretable.\n\nqap_run(net = qap_results[[1]],\n        variables = c(\"same_sex\", \"both_race_White\"),\n        dependent = NULL,\n        directed = T,\n        family = \"linear\")\n\nmodel_results[[1]]\n\n# A tibble: 3 × 3\n  covars          estimate pvalue\n  &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt;\n1 intercept        0.00170   0.79\n2 same_sex         0.993     0   \n3 both_race_White  0.254     0   \n\n\nThe MRAQP analysis through qap_run() outputs a list of two objects. The first contains a summary of model results akin to a traditional regression output. In this analysis, it is clear that sharing the same sex is very predictive of having a shared tie in this high-school. Both students being white is also predictive, although not at the same magnitude."
  },
  {
    "objectID": "vignette.html#role-analysis",
    "href": "vignette.html#role-analysis",
    "title": "R Vignette",
    "section": "Role Analysis",
    "text": "Role Analysis\n@Tom Wolff"
  },
  {
    "objectID": "data_storage.html",
    "href": "data_storage.html",
    "title": "Data storage",
    "section": "",
    "text": "We are currently in the process of completing a beta version of our data storage component. If you are interested in learning more and being kept afloat of updates, please share you contact at gv42@duke.edu. We will make sure to contact you with more information as development continues.\n\n\n\n Back to top"
  }
]